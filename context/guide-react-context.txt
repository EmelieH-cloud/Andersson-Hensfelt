

Grundl칛ggande begrepp:

1. **React Context**  
2. **Children i React**  
3. **TypeScript och typer (Types)**  

---

### **1. Vad 칛r React Context?**

**React Context** kan liknas vid en stor "l친da" som inneh친ller information som vi vill dela med flera delar av v친r applikation (komponenter) utan att beh칬va skicka den genom props f칬r varje komponent. Ist칛llet kan alla komponenter som 칛r "n칛rst친ende" till denna l친da f친 tillg친ng till inneh친llet.

T칛nk dig att du har en butik (din app) och i den butiken finns en **central kassa (Context)** d칛r alla kan f친 tillg친ng till samma information, som i ditt fall 칛r **temat** (t.ex. m칬rkt eller ljust). Ist칛llet f칬r att g친 till varje hylla (komponent) och be om information om temat, kan alla hyllor f친 tillg친ng till temat direkt fr친n kassan (Context).

I React g칬r vi det s친 h칛r:

1. Skapar en **context** d칛r vi s칛tter den data vi vill dela.
2. Skapar en **provider** som g칬r datan tillg칛nglig f칬r alla komponenter som beh칬ver den.
3. Anv칛nder en **hook** f칬r att h칛mta den datan d칛r vi beh칬ver den.

---

### **2. Vad 칛r `ThemeProvider`?**

**`ThemeProvider`** 칛r som en **l친da (provider)** som erbjuder temainformationen till alla komponenter som ligger inuti den.  

**T칛nk dig att:**
- Vi har en butik (v친r React-app).
- Vi s칛tter temat i kassan (ThemeProvider).
- N칛r en kund (komponent) kommer in i butiken, kan de g친 till kassan och f친 reda p친 temat.

Utan en `ThemeProvider` skulle varje enskild komponent beh칬va fr친ga f칬r sig sj칛lv om temat, eller vi skulle beh칬va skicka temainformation via **props** i varje komponent. Det blir snabbt r칬rigt!

S친 **`ThemeProvider`** g칬r det m칬jligt f칬r hela din app att ha tillg친ng till temat utan att beh칬va skicka det till varje komponent individuellt.

### **S친 h칛r fungerar `ThemeProvider`**:
```tsx
// ThemeProvider 칛r en komponent som hanterar och delar temat i hela appen
export const ThemeProvider = ({ children }: { children: ReactNode }) => {
    const [theme, setTheme] = useState<Theme>(() => {
        return (localStorage.getItem("theme") as Theme) || "light";
    });

    const toggleTheme = () => {
        const newTheme = theme === "light" ? "dark" : "light"; // Byt tema
        setTheme(newTheme); // Uppdatera state
        localStorage.setItem("theme", newTheme); // Spara i localStorage
    };

    return (
        <ThemeContext.Provider value={{ theme, toggleTheme }}>
            {children}
        </ThemeContext.Provider>
    );
};
```

- **`ThemeProvider`** 칛r en komponent (en "l친da" d칛r vi lagrar och erbjuder temat).
- **`children`** 칛r alla komponenter som ligger inom **ThemeProvider**. Du kan t칛nka p친 det som barn i en familj, som 칛r **komponenter** som ligger under den stora "l친dan". Allt inneh친ll som finns inuti `ThemeProvider` f친r tillg친ng till temat.

---

### **3. Vad 칛r `children` i React?**

`children` 칛r ett s칛tt i React att beskriva de komponenter som finns inuti en annan komponent. I v친rt fall n칛r vi anv칛nder `ThemeProvider`, betyder det alla de komponenter som ligger inom denna provider och vill anv칛nda temat.

Exempel:
```tsx
<ThemeProvider>
    <SomeComponent />
    <AnotherComponent />
</ThemeProvider>
```

- `ThemeProvider` "wrappar" in de andra komponenterna (`SomeComponent` och `AnotherComponent`), vilket g칬r att dessa f친r tillg친ng till temat genom **React Context**.
- **`children`** anv칛nds f칬r att beskriva dessa "barn-komponenter".

---

### **4. Varf칬r beh칬ver vi Types i TypeScript?**

TypeScript hj칛lper oss att skriva mer robust kod genom att l칛gga till **typer** som s칛kerst칛ller att vi inte g칬r fel. I det h칛r fallet, genom att skapa en **typ f칬r `Theme`**, vet vi att temat bara kan vara `"light"` eller `"dark"`. 

Utan TypeScript skulle vi kunna skriva:
```tsx
const [theme, setTheme] = useState("light");
```

Men det h칛r ger oss inga garantier om vad `theme` kan vara. I TypeScript kan vi s칛ga:
```tsx
type Theme = "light" | "dark"; // Vi s칛kerst칛ller att theme bara kan vara "light" eller "dark"
const [theme, setTheme] = useState<Theme>("light");
```

Detta g칬r det l칛ttare att hitta fel och ger oss en tydlig f칬rst친else f칬r vilka v칛rden variablerna kan ha. **`"light" | "dark"`** kallas en **"Union Type"** och betyder att `theme` kan vara antingen `"light"` eller `"dark"`.

---

### **5. Hur anv칛nder vi allt tillsammans?**

H칛r 칛r hela fl칬det i appen:

1. **`ThemeProvider`** skapar en **central plats** (Context) f칬r att hantera temat.
2. **`children`** g칬r att alla komponenter **inuti ThemeProvider** f친r tillg친ng till temat.
3. **`useState` och `toggleTheme`** l친ter oss lagra och byta mellan temana ("light" och "dark").
4. **`useContext`** anv칛nds f칬r att h칛mta temat i en annan komponent via v친r custom hook `useTheme`.

### **Exempel:**

```tsx
import { createContext, useContext, useState, ReactNode } from "react";

// Skapa en typ f칬r temat
type Theme = "light" | "dark";

// Skapa ett interface f칬r ThemeContext
interface ThemeContextType {
    theme: Theme;
    toggleTheme: () => void;
}

// Skapa en context f칬r temat
const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// Skapa en provider som g칬r temat tillg칛ngligt f칬r hela appen
export const ThemeProvider = ({ children }: { children: ReactNode }) => {
    const [theme, setTheme] = useState<Theme>("light");

    const toggleTheme = () => {
        setTheme(theme === "light" ? "dark" : "light");
    };

    return (
        <ThemeContext.Provider value={{ theme, toggleTheme }}>
            {children}
        </ThemeContext.Provider>
    );
};

// Skapa en custom hook f칬r att f친 친tkomst till temat
export const useTheme = () => {
    const context = useContext(ThemeContext);
    if (!context) throw new Error("useTheme m친ste anv칛ndas inom ThemeProvider");
    return context;
};
```

- **`ThemeProvider`** g칬r temat tillg칛ngligt f칬r alla komponenter i appen.
- **`children`** 칛r de komponenter som kan anv칛nda temat.
- **`useTheme`** 칛r en hook som vi anv칛nder f칬r att h칛mta temat i andra komponenter.

---

Jag hoppas att detta g칬r koncepten mycket tydligare! 游땕 Om det 칛r n친got mer som k칛nns oklart eller om du vill ha fler f칬rklaringar, s친 hj칛lper jag g칛rna till!